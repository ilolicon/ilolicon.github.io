<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Docker is a platform designed to help developers build, share, and run modern applications. We handle the tedious setup, so you can focus on the code."><title>Docker</title><link rel=canonical href=https://ilolicon.github.io/p/docker/><link rel=stylesheet href=/scss/style.min.abbd69b2908fdfcd5179898beaafd374514a86538d81639ddd2c58c06ae54e40.css><meta property="og:title" content="Docker"><meta property="og:description" content="Docker is a platform designed to help developers build, share, and run modern applications. We handle the tedious setup, so you can focus on the code."><meta property="og:url" content="https://ilolicon.github.io/p/docker/"><meta property="og:site_name" content="ilolicon's Blog"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="Cloud Native"><meta property="article:tag" content="Docker"><meta property="article:tag" content="Dockerfile"><meta property="article:tag" content="Container"><meta property="article:published_time" content="2020-06-12T12:10:00+08:00"><meta property="article:modified_time" content="2020-06-12T12:10:00+08:00"><meta name=twitter:title content="Docker"><meta name=twitter:description content="Docker is a platform designed to help developers build, share, and run modern applications. We handle the tedious setup, so you can focus on the code."><link rel="shortcut icon" href=/img/favicon.ico></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu96a5ab8e0364e843af4687201b687892_162934_300x0_resize_box_3.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a>
<span class=emoji>🍥</span></figure><div class=site-meta><h1 class=site-name><a href=/>ilolicon's Blog</a></h1><h2 class=site-description>Keep Calm and Carry On.</h2></div></header><ol class=social-menu><li><a href=https://github.com/ilolicon target=_blank title=GitHub rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://twitter.com target=_blank title=Twitter rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Archives</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>Search</span></a></li><li><a href=/links/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg><span>Links</span></a></li><div class=menu-bottom-section><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>暗色模式</span></li></div></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#主机级虚拟化>主机级虚拟化</a><ol><li><a href=#type1>Type1</a></li><li><a href=#type2>Type2</a></li></ol></li><li><a href=#容器级虚拟化>容器级虚拟化</a><ol><li><a href=#namespace>Namespace</a></li><li><a href=#control-groups>Control Groups</a></li><li><a href=#lxc>LXC</a></li><li><a href=#容器编排>容器编排</a></li></ol></li><li><a href=#docker>Docker</a><ol><li><a href=#oci>OCI</a></li><li><a href=#runc>runC</a></li><li><a href=#docker-architecture>docker architecture</a></li><li><a href=#docker-objects>docker objects</a><ol><li><a href=#images>Images</a></li><li><a href=#containers>Containers</a></li></ol></li><li><a href=#docker-install>docker install</a><ol><li><a href=#docker-cerepo>docker-ce.repo</a></li><li><a href=#镜像加速>镜像加速</a></li></ol></li><li><a href=#docker-cli>docker cli</a></li><li><a href=#docker-event-state>docker event state</a></li><li><a href=#docker-image>docker image</a><ol><li><a href=#docker-image-layer>docker image layer</a></li><li><a href=#aufs>aufs</a></li><li><a href=#docekr-registry>docekr registry</a></li><li><a href=#registryrepository-and-index>registry(repository and index)</a></li><li><a href=#docker-hub>docker hub</a></li><li><a href=#docker-pull>docker pull</a></li><li><a href=#镜像的相关操作>镜像的相关操作</a></li></ol></li><li><a href=#容器虚拟化网络>容器虚拟化网络</a><ol><li><a href=#容器虚拟化网络概述>容器虚拟化网络概述</a></li><li><a href=#bridged-containers>Bridged Containers</a></li><li><a href=#joined-container>Joined Container</a></li><li><a href=#open-container>Open Container</a></li><li><a href=#closed-container>Closed Container</a></li><li><a href=#自定义docker0桥的网络信息>自定义docker0桥的网络信息</a></li><li><a href=#使用tcp套接字>使用TCP套接字</a></li><li><a href=#创建自定义网络>创建自定义网络</a></li></ol></li><li><a href=#docker存储卷>docker存储卷</a><ol><li><a href=#why-data-volumes存储卷>Why Data Volumes(存储卷)</a></li><li><a href=#data-volumes>Data volumes</a></li><li><a href=#sharing-volumes>Sharing volumes</a></li></ol></li></ol></li><li><a href=#dockerfile>Dockerfile</a><ol><li><a href=#dockerfile-format>Dockerfile Format</a></li><li><a href=#dockerignore-file>.dockerignore file</a></li><li><a href=#environment-replacement>Environment replacement</a></li><li><a href=#docekrfile-instructions>Docekrfile Instructions</a><ol><li><a href=#from>FROM</a></li><li><a href=#maintanierdeprecated>MAINTANIER(deprecated)</a></li><li><a href=#label>LABEL</a></li><li><a href=#copy>COPY</a></li><li><a href=#add>ADD</a></li><li><a href=#workdir>WORKDIR</a></li><li><a href=#volume>VOLUME</a></li><li><a href=#expose>EXPOSE</a></li><li><a href=#env>ENV</a></li><li><a href=#run>RUN</a></li><li><a href=#cmd>CMD</a></li><li><a href=#entrypoint>ENTRYPOINT</a></li><li><a href=#user>USER</a></li><li><a href=#healthcheck>HEALTHCHECK</a></li><li><a href=#shell>SHELL</a></li><li><a href=#stopsignal>STOPSIGNAL</a></li><li><a href=#arg>ARG</a></li><li><a href=#onbuild>ONBUILD</a></li></ol></li></ol></li><li><a href=#docker资源限制>Docker资源限制</a><ol><li><a href=#oome>OOME</a><ol><li><a href=#limit-a-containers-access-to-memory>Limit a container’s access to memory</a></li><li><a href=#--memory-swap>&ndash;memory-swap</a></li></ol></li><li><a href=#cpu>CPU</a><ol><li><a href=#configure-the-default-cfs-scheduler>Configure the default CFS scheduler</a></li></ol></li><li><a href=#测试>测试</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/cloudnative/ style=background-color:#2a9d8f;color:#fff>CloudNative</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/docker/>Docker</a></h2><h3 class=article-subtitle>Docker is a platform designed to help developers build, share, and run modern applications. We handle the tedious setup, so you can focus on the code.</h3></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Jun 12, 2020</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>阅读时长: 18 分钟</time></div></footer></div></header><section class=article-content><p><a class=link href=https://docs.docker.com/ target=_blank rel=noopener><img src=https://img.shields.io/badge/Docker-README-00A6ED loading=lazy alt="docker readme"></a></p><p><a class=link href=https://www.docker.com/ target=_blank rel=noopener><img src=/p/docker/icons/docker-icon.svg loading=lazy alt=docker></a></p><h2 id=主机级虚拟化>主机级虚拟化</h2><p><a class=link href=https://virtual.51cto.com/art/201904/594481.htm target=_blank rel=noopener>Type1和Type2虚拟机管理程序区别</a></p><h3 id=type1>Type1</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Type1虚拟机管理程序直接在主机的物理硬件上运行 它被称为裸机虚拟机管理程序
</span></span><span class=line><span class=cl>它不必预先加载底层操作系统 通过直接访问底层硬件而无需其他软件<span class=o>(</span>例如操作系统和设备驱动程序<span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>VMware ESXi</li><li>Microsoft Hyper-V服务器</li><li>开源KVM</li><li>&mldr;</li></ul><h3 id=type2>Type2</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Type2虚拟机管理程序通常安装在现有操作系统之上 它称为托管虚拟机管理程序
</span></span><span class=line><span class=cl>因为它依赖于主机预先安装的操作系统来管理对CPU/内存/存储和网络资源的调用
</span></span></code></pre></td></tr></table></div></div><ul><li>VMware Fusion</li><li>Oracle VM VirtualBox</li><li>用于x86的Oracle VM Server</li><li>Oracle Solaris Zones</li><li>Parallels</li><li>VMware Workstation</li><li>&mldr;</li></ul><h2 id=容器级虚拟化>容器级虚拟化</h2><h3 id=namespace>Namespace</h3><p><a class=link href=https://man7.org/linux/man-pages/man7/namespaces.7.html target=_blank rel=noopener>man-namespaces</a></p><p><a class=link href=https://lwn.net/Articles/531381/ target=_blank rel=noopener>namespaces API</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>clone<span class=o>()</span>   <span class=c1># Creating a child in a new namespace</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>setns<span class=o>()</span>   <span class=c1># Joining an existing namespace</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>unshare<span class=o>()</span> <span class=c1># Leaving a namespace</span>
</span></span></code></pre></td></tr></table></div></div><p>Linux Namespaces</p><div class=table-wrapper><table><thead><tr><th>namespace</th><th>系统调用参数</th><th>隔离内容</th><th>内核版本</th></tr></thead><tbody><tr><td>UTS</td><td>CLONE_NEWUTS</td><td>主机名和域名</td><td>2.6.19</td></tr><tr><td>IPC</td><td>CLONE_NEWIPC</td><td>信号量/消息队列/共享内存</td><td>2.6.19</td></tr><tr><td>PID</td><td>CLONE_NEWPID</td><td>进程编号</td><td>2.6.24</td></tr><tr><td>Network</td><td>CLONE_NEWNET</td><td>网络设备/网络栈/端口等</td><td>2.6.29</td></tr><tr><td>Mount</td><td>CLONE_NEWNS</td><td>挂载点(文件系统)</td><td>2.4.19</td></tr><tr><td>User</td><td>CLONE_NEWUSER</td><td>用户和用户组</td><td>3.8</td></tr></tbody></table></div><h3 id=control-groups>Control Groups</h3><p><a class=link href=https://man7.org/linux/man-pages/man7/cgroups.7.html target=_blank rel=noopener>man-cgroups</a></p><p><a class=link href=https://tech.meituan.com/2015/03/31/cgroups.html target=_blank rel=noopener>linux资源管理之cgroups简介</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>cgroups是Linux内核提供的一种可以限制单个进程或者多个进程所使用资源的机制 可以对cpu/内存等资源实现精细化的控制
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>cgroups 的全称是control groups 
</span></span><span class=line><span class=cl>cgroups为每种可以控制的资源定义了一个子系统 典型的子系统介绍如下
</span></span></code></pre></td></tr></table></div></div><ul><li>blkio 块设备IO</li><li>cpu CPU</li><li>cpuacct CPU资源使用报告</li><li>cpuset 多处理器平台上的CPU集合(按核/按比例)</li><li>devices 设备访问</li><li>freezer 挂起或恢复任务</li><li>memory 内存用量及报告</li><li>perf_event 对cgroup中的任务进行统一性能测试</li><li>net_cls cgroup中的任务创建的数据报文的类别标识符</li></ul><h3 id=lxc>LXC</h3><p><a class=link href=https://www.redhat.com/zh/topics/containers/whats-a-linux-container target=_blank rel=noopener>whats-a-linux-container</a></p><ul><li>LinuX Container<ul><li>lxc-create(创建namespace)</li><li>template(拉取所需发行版的仓库相关包进行安装)</li></ul></li></ul><h3 id=容器编排>容器编排</h3><ul><li>machine + swarm + docker compose(单机编排)</li><li>mesos + marathon</li><li>kubernetes(k8s)</li></ul><h2 id=docker>Docker</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># docker 容器引擎的发展</span>
</span></span><span class=line><span class=cl><span class=c1># LXC -&gt; libcontainer -&gt; runC</span>
</span></span><span class=line><span class=cl>-&gt; libcontainer<span class=o>(</span>docker研发的容器引擎 替换LXC<span class=o>)</span> 
</span></span><span class=line><span class=cl>-&gt; runC<span class=o>(</span>容器运行时环境标准 Docker将RunC捐赠给OCI作为OCI容器运行时标准的参考实现<span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p><a class=link href=https://os.51cto.com/art/202110/687502.htm target=_blank rel=noopener>docker/containerd/runC分别是什么</a></p><h3 id=oci>OCI</h3><p><a class=link href=https://opencontainers.org/ target=_blank rel=noopener><img src=/p/docker/icons/opencontainers-icon.svg loading=lazy alt="Open Container Initiative"></a></p><p>Open Container Initiative</p><ul><li>由Linux基金会主导于2015年6月创立</li><li>旨在围绕容器格式和运行时制定一个开放的工业化标准</li><li>contains two specifications<ul><li>the Runtime Specification (runtime-spec) 运行时标准(规范)</li><li>the Image Specification (image-spec) 镜像格式标准(规范)</li></ul></li><li>The Runtime Specification outlines how to run a &ldquo;filesystem bundle&rdquo; that is unpacked on disk</li><li>At a high-level an OCI implementation would download an OCI Image then unpack that image into an OCI Runtime filesystem bundle</li></ul><h3 id=runc>runC</h3><p><a class=link href=https://github.com/opencontainers/runc target=_blank rel=noopener>runC</a></p><ul><li>OCF: Open Container Format</li><li>runC: runc is a CLI tool for spawning and running containers on Linux according to the OCI specification</li></ul><h3 id=docker-architecture>docker architecture</h3><p><a class=link href=https://docs.docker.com/get-started/overview/#docker-architecture target=_blank rel=noopener><img src=/p/docker/icons/architecture.svg loading=lazy alt="docker architecture"></a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Client -&gt; Daemon<span class=o>(</span>REST API, over UNIX sockets or a network interface<span class=o>)</span>
</span></span><span class=line><span class=cl>Registry -&gt; Host<span class=o>(</span>https/http<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Registry: 仓库名<span class=o>(</span>repo name<span class=o>)</span> + 标签<span class=o>(</span>tag<span class=o>)</span> 唯一标识一个镜像
</span></span><span class=line><span class=cl>-&gt; nginx:1.14.0
</span></span><span class=line><span class=cl>-&gt; nginx:latest<span class=o>(</span>default 最新版<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Images: An image is a read-only template with instructions <span class=k>for</span> creating a Docker container
</span></span><span class=line><span class=cl>Images：静态的 不会运行
</span></span><span class=line><span class=cl>Containers：动态 有生命周期 类似命令
</span></span><span class=line><span class=cl>  /bin/ls
</span></span><span class=line><span class=cl>    - ls /etc
</span></span><span class=line><span class=cl>    - ls /var
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Moby
</span></span><span class=line><span class=cl>docker-ee <span class=c1># 企业版</span>
</span></span><span class=line><span class=cl>docker-ce <span class=c1># 社区版</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=docker-objects>docker objects</h3><p><a class=link href=https://docs.docker.com/get-started/overview/#docker-objects target=_blank rel=noopener>docker objects</a></p><ul><li>images</li><li>containers</li><li>networks</li><li>volumes</li><li>plugins</li><li>other objects</li></ul><h4 id=images>Images</h4><ul><li>An image is a read-only template with instructions for creating a Docker container</li><li>Often, an image is based on another image, with some additional customization</li><li>You might create your own images or you might only use those created by others and published in a registry</li></ul><h4 id=containers>Containers</h4><ul><li>A container is a runnable instance of an image</li><li>You can create/start/stop/move or delete a container using the Docker API or CLI</li><li>You can connect a container to one or more networks, attach storage to it, or even create a new image based on its current state</li></ul><h3 id=docker-install>docker install</h3><p><a class=link href=https://docs.docker.com/engine/install/ target=_blank rel=noopener>Install Docker Engine</a></p><p><a class=link href=https://mirrors.aliyun.com/docker-ce/ target=_blank rel=noopener>阿里云Mirrors docker-ce</a></p><h4 id=docker-cerepo>docker-ce.repo</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>[</span>docker-ce-stable<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=nv>name</span><span class=o>=</span>Docker CE Stable - <span class=nv>$basearch</span>
</span></span><span class=line><span class=cl><span class=nv>baseurl</span><span class=o>=</span>https://download.docker.com/linux/centos/<span class=nv>$releasever</span>/<span class=nv>$basearch</span>/stable
</span></span><span class=line><span class=cl><span class=c1># baseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/$releasever/$basearch/stable</span>
</span></span><span class=line><span class=cl><span class=nv>enabled</span><span class=o>=</span><span class=m>1</span>
</span></span><span class=line><span class=cl><span class=nv>gpgcheck</span><span class=o>=</span><span class=m>1</span>
</span></span><span class=line><span class=cl><span class=nv>gpgkey</span><span class=o>=</span>https://download.docker.com/linux/centos/gpg
</span></span></code></pre></td></tr></table></div></div><h4 id=镜像加速>镜像加速</h4><ul><li>docker cn</li><li><a class=link href=https://help.aliyun.com/document_detail/60750.html target=_blank rel=noopener>阿里云官方镜像加速</a></li><li>中国科技大学</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 配置文件</span>
</span></span><span class=line><span class=cl>/etc/docker/daemon.json
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 更换镜像下载仓库链接</span>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;registry-mirrors&#34;</span>: <span class=o>[</span><span class=s2>&#34;系统分配前缀.mirror.aliyuncs.com &#34;</span><span class=o>]</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=docker-cli>docker cli</h3><p><a class=link href=https://docs.docker.com/reference/ target=_blank rel=noopener>docekr-reference</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker --help
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># docker event state 涉及部分常用命令</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=docker-event-state>docker event state</h3><p><a class=link href=https://docs.docker.com/engine/reference/commandline/events/ target=_blank rel=noopener><img src=/p/docker/icons/docker-event-state.jpg width=975 height=496 srcset="/p/docker/icons/docker-event-state_hu1fb588f0bea85f45f342114261d318d9_52218_480x0_resize_q75_box.jpg 480w, /p/docker/icons/docker-event-state_hu1fb588f0bea85f45f342114261d318d9_52218_1024x0_resize_q75_box.jpg 1024w" loading=lazy alt="docker event state" class=gallery-image data-flex-grow=196 data-flex-basis=471px></a></p><h3 id=docker-image>docker image</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Docker镜像含有启动容器所需的文件系统及其内容 因此 其用于创建并启动docker容器
</span></span></code></pre></td></tr></table></div></div><h4 id=docker-image-layer>docker image layer</h4><p><img src=/p/docker/icons/docker-base-image.png width=800 height=600 srcset="/p/docker/icons/docker-base-image_hu2e660399b17286aa9ee92b351b0a326a_72247_480x0_resize_box_3.png 480w, /p/docker/icons/docker-base-image_hu2e660399b17286aa9ee92b351b0a326a_72247_1024x0_resize_box_3.png 1024w" loading=lazy alt=分层构建 class=gallery-image data-flex-grow=133 data-flex-basis=320px></p><ul><li>采用分层构建机制 最底层为bootfs 其它为rootfs<ul><li>bootfs: 用于<code>系统引导</code>的文件系统 包括<code>bootloader</code>和<code>kernel</code> 容器启动完成后会被卸载以节约内存资源</li><li>rootfs: 位于bootfs之上 表现为docker容器的根文件系统<ul><li>传统模式中 系统启动时 内核挂载rootfs时会首先将其挂载为<code>只读</code>模式(自检) 完整性自检完成后将其重新挂载为读写模式</li><li>docker中 rootfs由内核挂载为<code>只读</code>模式 而后通过<code>联合挂载</code>技术额外挂载一个<code>可写</code>层</li></ul></li></ul></li><li>docker image layer<ul><li>位与下层的镜像成为父镜像(parent image) 最底层的称为基础镜像(base image)</li><li>最上层的为<code>可读写</code>层 其下的均为<code>只读</code>层</li></ul></li></ul><p><img src=/p/docker/icons/docker-image-layer.png width=651 height=430 srcset="/p/docker/icons/docker-image-layer_hu698cd364b218f2ed2f564ab487df7ce9_26319_480x0_resize_box_3.png 480w, /p/docker/icons/docker-image-layer_hu698cd364b218f2ed2f564ab487df7ce9_26319_1024x0_resize_box_3.png 1024w" loading=lazy alt="docker image layer" class=gallery-image data-flex-grow=151 data-flex-basis=363px></p><h4 id=aufs>aufs</h4><ul><li>Advanced Mult-Layered Unification Filesystem 高级多层统一文件系统</li><li>用于为Linux文件系统实现<code>联合挂载</code></li><li>aufs是之前UnionFS的重新实现 2006年由Junjiro Okajima开发</li><li>Docekr最初使用aufs作为容器文件系统层 它目前仍作为存储后端之一来支持</li><li>aufs的竞争产品是overlayfs 后者自从3.18版本开始被合并到Linux内核</li><li>docker的分层镜像 除aufs之外 docker还支持btrfs/devicemapper/vfs等<ul><li>Ubuntu系统下 docekr默认Ubuntu的aufs 而在CentOS7上 用的是devicemapper(新版默认使用overlay2)</li></ul></li></ul><h4 id=docekr-registry>docekr registry</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>启动容器时 docker daemon 会试图从本地获取相关的镜像 本地镜像不存在时 其将从Registry中下载该镜像并保存到本地
</span></span></code></pre></td></tr></table></div></div><ul><li>Registry用于保存docker镜像 包括镜像的层次结构和元数据</li><li>用户可以自建Registry 也可以使用官方的Docker Hub</li><li>分类<ul><li>Sponsor Registry: 第三方的registry 供客户和Docker社区使用(捐赠者)</li><li>Mirror Registry: 第三方的registry 只让客户使用(云)</li><li>Vendor Registry: 由发布Docker镜像的供应商提供的registry(redhat)</li><li>Private Registry: 通过设有防火墙和额外安全层的私有实体提供的registry(自建)<ul><li><a class=link href=https://hub.docker.com/_/registry target=_blank rel=noopener>docker-registry/docker-distribution</a></li><li><a class=link href=https://goharbor.io/ target=_blank rel=noopener>harbor</a></li></ul></li></ul></li></ul><p><img src=/p/docker/icons/docker-registry.png width=1001 height=516 srcset="/p/docker/icons/docker-registry_hua933c1d1f3b2ebd39d6af526d8740ae9_269181_480x0_resize_box_3.png 480w, /p/docker/icons/docker-registry_hua933c1d1f3b2ebd39d6af526d8740ae9_269181_1024x0_resize_box_3.png 1024w" loading=lazy alt="docker registry" class=gallery-image data-flex-grow=193 data-flex-basis=465px></p><h4 id=registryrepository-and-index>registry(repository and index)</h4><ul><li>Repository<ul><li>由某特定的docker镜像的<code>所有迭代版本</code>组成的镜像仓库</li><li>一个Registry中可以存在多个Repository<ul><li>Repository可分为<code>顶层仓库</code>和<code>用户仓库</code></li><li>用户仓库名称格式为<code>用户名/仓库名</code> => <code>ilolicon/nginx</code></li></ul></li><li>每个仓库可以包含多个Tag(标签) 每个标签对应一个镜像</li></ul></li><li>Index<ul><li>维护用户账户/镜像的校验以及公共命名空间的信息</li><li>相当于为Registry提供一个完成用户认证等功能的检索接口</li></ul></li></ul><h4 id=docker-hub>docker hub</h4><p><a class=link href=https://docs.docker.com/docker-hub/ target=_blank rel=noopener>DockerHub</a></p><p>Docker Hub provides the following major features:</p><ul><li><a class=link href=https://docs.docker.com/docker-hub/repos/ target=_blank rel=noopener>Repositories</a>: Push and pull container images</li><li><a class=link href=https://docs.docker.com/docker-hub/orgs/ target=_blank rel=noopener>Teams & Organizations</a>: Manage access to private repositories of container images</li><li><a class=link href=https://docs.docker.com/docker-hub/official_images/ target=_blank rel=noopener>Docker Official Images</a>: Pull and use high-quality container images provided by Docker</li><li><a class=link href=https://docs.docker.com/docker-hub/publish/ target=_blank rel=noopener>Docker Verified Publisher Images</a>: Pull and use high- quality container images provided by external vendors</li><li><a class=link href=https://docs.docker.com/docker-hub/builds/ target=_blank rel=noopener>Builds</a>: Automatically build container images from GitHub and Bitbucket and push them to Docker Hub</li><li><a class=link href=https://docs.docker.com/docker-hub/webhooks/ target=_blank rel=noopener>Webhooks</a>: Trigger actions after a successful push to a repository to integrate Docker Hub with other services</li></ul><h4 id=docker-pull>docker pull</h4><p><a class=link href=https://docs.docker.com/engine/reference/commandline/pull/ target=_blank rel=noopener>pull-commandline</a></p><p><a class=link href=https://quay.io/ target=_blank rel=noopener>quay.io</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ docker pull &lt;registry&gt;<span class=o>[</span>:port<span class=o>]</span>/<span class=o>[</span>&lt;namespace&gt;/<span class=o>]</span>&lt;name&gt;:&lt;tag&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># e.g:</span>
</span></span><span class=line><span class=cl><span class=c1># registry: quay.io</span>
</span></span><span class=line><span class=cl><span class=c1># port: 443(没指定 默认)</span>
</span></span><span class=line><span class=cl><span class=c1># namespace: coreos</span>
</span></span><span class=line><span class=cl><span class=c1># name: flannel(repostory名称)</span>
</span></span><span class=line><span class=cl><span class=c1># tag: v0.15.1-arm64 指定版本</span>
</span></span><span class=line><span class=cl>$ docker pull quay.io/coreos/flannel:v0.15.1-arm64
</span></span></code></pre></td></tr></table></div></div><div class=table-wrapper><table><thead><tr><th>Namespace</th><th>Examples(&lt;namespace/name>)</th></tr></thead><tbody><tr><td>organization</td><td>redhat/kubernetes google/kubernetes</td></tr><tr><td>login(user name)</td><td>alice/application ilolicon/application</td></tr><tr><td>role</td><td>devel/database test/database prod/database</td></tr></tbody></table></div><h4 id=镜像的相关操作>镜像的相关操作</h4><p><img src=/p/docker/icons/docker-image-create.png width=1330 height=778 srcset="/p/docker/icons/docker-image-create_hu35c6b1faa4899c64f224a792974bf729_550128_480x0_resize_box_3.png 480w, /p/docker/icons/docker-image-create_hu35c6b1faa4899c64f224a792974bf729_550128_1024x0_resize_box_3.png 1024w" loading=lazy alt="docker image create" class=gallery-image data-flex-grow=170 data-flex-basis=410px></p><ul><li><p>镜像的生成途径</p><ul><li><a class=link href=https://docs.docker.com/engine/reference/builder/ target=_blank rel=noopener>Dockerfile</a></li><li><a class=link href=https://docs.docker.com/engine/reference/commandline/commit/ target=_blank rel=noopener>基于容器制作</a></li><li>Docekr Hub automated builds(仍是基于Dockerfile)</li></ul></li><li><p>另一种镜像分发方式</p><ul><li><a class=link href=https://docs.docker.com/engine/reference/commandline/save/ target=_blank rel=noopener>docker-save</a></li><li><a class=link href=https://docs.docker.com/engine/reference/commandline/load/ target=_blank rel=noopener>docker-load</a></li></ul></li></ul><h3 id=容器虚拟化网络>容器虚拟化网络</h3><h4 id=容器虚拟化网络概述>容器虚拟化网络概述</h4><p><a class=link href=https://www.cnblogs.com/hukey/p/14062579.html target=_blank rel=noopener>容器虚拟化网络</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>OVS: Open VSwitch
</span></span><span class=line><span class=cl>SDN
</span></span><span class=line><span class=cl>Overlay Network<span class=o>(</span>叠加网络<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># docker默认的三种网络</span>
</span></span><span class=line><span class=cl><span class=o>[</span>ilolicon@master ~<span class=o>]</span>$ docker network ls
</span></span><span class=line><span class=cl>NETWORK ID     NAME      DRIVER    SCOPE
</span></span><span class=line><span class=cl>78fa953ed316   bridge    bridge    <span class=nb>local</span> <span class=c1># 桥接 默认NAT桥</span>
</span></span><span class=line><span class=cl>8ec55273feb2   host      host      <span class=nb>local</span> <span class=c1># 让容器直接使用宿主机的网络名称空间</span>
</span></span><span class=line><span class=cl>9081fe29a218   none      null      <span class=nb>local</span> <span class=c1># 只有lo接口 没有其他网卡</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[</span>ilolicon@master ~<span class=o>]</span>$ yum -y install bridge-utils
</span></span><span class=line><span class=cl><span class=o>[</span>ilolicon@master ~<span class=o>]</span>$ brctl show
</span></span></code></pre></td></tr></table></div></div><p><img src=/p/docker/icons/four-network-container-archetypes.png width=921 height=563 srcset="/p/docker/icons/four-network-container-archetypes_hu5fe812ea1b5552a81ec2413a76585961_183707_480x0_resize_box_3.png 480w, /p/docker/icons/four-network-container-archetypes_hu5fe812ea1b5552a81ec2413a76585961_183707_1024x0_resize_box_3.png 1024w" loading=lazy alt="Four network container archetypes" class=gallery-image data-flex-grow=163 data-flex-basis=392px></p><p><a class=link href=https://docs.docker.com/network/ target=_blank rel=noopener>docker-docs:network overview</a></p><ul><li>Closed Container</li><li>Bridged Container(NAT桥接网络 默认)</li><li>Joined Container(联盟式容器网络 相对隔离 只是共享同一个网络名称空间)</li><li>Open Container(开放式容器网络 共享宿主机网络名称空间)</li></ul><h4 id=bridged-containers>Bridged Containers</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Bridged Containers可以为docker run命令使用</span>
</span></span><span class=line><span class=cl><span class=c1># &#34;--hostname HOSTNAME&#34; 选项为容器指定主机名</span>
</span></span><span class=line><span class=cl>$ docker run --rm --net bridge --hostname cloudnative.ilolicon.com busybox:latest hostname
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># &#34;--dns DNS_SERVER_IP&#34; 选项能够为容器指定所使用的dns服务器地址</span>
</span></span><span class=line><span class=cl>$ docker run --rm --dns 8.8.8.8 --dns 8.8.4.4 busybox:latest nslookup docker.com
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># &#34;--add-host HOSTNAME:IP&#34; 选项能够为容器指定本地主机名解析项</span>
</span></span><span class=line><span class=cl>$ docker run --rm --dns 172.16.0.1 --add-host <span class=s2>&#34;docker.com:172.16.0.100&#34;</span> busybox:latest cat /etc/hosts
</span></span></code></pre></td></tr></table></div></div><h5 id=opening-inbound-communication--expose>Opening Inbound Communication / Expose</h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>-p选项的使用格式
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 将指定的容器端口&lt;containerPort&gt; 映射至主机所有地址的一个动态端口</span>
</span></span><span class=line><span class=cl>-p &lt;containerPort&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 将指定的容器端口&lt;containerPort&gt; 映射至指定的主机端口&lt;hostPort&gt;</span>
</span></span><span class=line><span class=cl>-p &lt;hostPort&gt;:&lt;containerPort&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 将指定的容器端口&lt;containerPort&gt; 映射至主机指定&lt;ip&gt;的动态端口</span>
</span></span><span class=line><span class=cl>-p &lt;ip&gt;::&lt;containerPort&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 将指定的容器端口&lt;containerPort&gt; 映射至主机指定&lt;ip&gt;的端口&lt;hostPort&gt;</span>
</span></span><span class=line><span class=cl>-p &lt;ip&gt;:&lt;hostPort&gt;:&lt;containerPort&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=s2>&#34;动态端口&#34;</span> 指随机端口 具体的映射结果可使用docker port命令查看
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Expose端口 还可以参考 -P 选项：暴露容器内部已指定的端口
</span></span></code></pre></td></tr></table></div></div><h4 id=joined-container>Joined Container</h4><ul><li>联盟式容器是指使用某个已存在容器的网络接口的容器 接口被联盟内的各容器共享使用(NTS Network IPC)</li><li>联盟式容器彼此间虽然共享同一个网络名称空间 但其它内部名称空间如: User/Mount等还是隔离的</li><li>联盟式容器彼此间存在端口冲突的可能性 使用此种模式的网络模型情况<ul><li>多个容器上的程序需要程序loopback接口互相通信</li><li>对某已存的容器的网络属性进行监控</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 创建一个监听于2222端口的http服务容器</span>
</span></span><span class=line><span class=cl>$ docker run --name t1 -it --rm busybox
</span></span><span class=line><span class=cl>/ <span class=c1># ifconfig</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 创建一个联盟式容器(--network指定使用t1的网络名称空间) 并查看其监听的端口</span>
</span></span><span class=line><span class=cl>$ docker run --name t2 -it --rm --network container:t1 busybox
</span></span><span class=line><span class=cl>/ <span class=c1># ifconfig</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=open-container>Open Container</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># --network 指定 host</span>
</span></span><span class=line><span class=cl><span class=c1># 直接使用宿主机的网络名称空间 无需再Expose端口</span>
</span></span><span class=line><span class=cl>$ docker run --rm -it --network host busybox
</span></span></code></pre></td></tr></table></div></div><h4 id=closed-container>Closed Container</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># --network none</span>
</span></span><span class=line><span class=cl>$ docker run --rm -it --network none busybox
</span></span></code></pre></td></tr></table></div></div><h4 id=自定义docker0桥的网络信息>自定义docker0桥的网络信息</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 编辑 /etc/docker/daemon.json 配置文件</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;bip&#34;</span>: <span class=s2>&#34;192.168.1.5/24&#34;</span>,
</span></span><span class=line><span class=cl>    <span class=s2>&#34;fixed-cidr&#34;</span>: <span class=s2>&#34;10.20.0.0/16&#34;</span>,
</span></span><span class=line><span class=cl>    <span class=s2>&#34;fixed-cidr-v6&#34;</span>: <span class=s2>&#34;2001:db8::/64&#34;</span>,
</span></span><span class=line><span class=cl>    <span class=s2>&#34;mtu&#34;</span>: <span class=s2>&#34;1500&#34;</span>,
</span></span><span class=line><span class=cl>    <span class=s2>&#34;default-gateway&#34;</span>: <span class=s2>&#34;10.20.1.1&#34;</span>,
</span></span><span class=line><span class=cl>    <span class=s2>&#34;default-gateway-v6&#34;</span>: <span class=s2>&#34;2001:db8:abcd::89&#34;</span>,
</span></span><span class=line><span class=cl>    <span class=s2>&#34;dns&#34;</span>: <span class=o>[</span><span class=s2>&#34;10.20.1.2&#34;</span>,<span class=s2>&#34;10.20.1.3&#34;</span><span class=o>]</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 核心选项为bip 即bridge ip之意 </span>
</span></span><span class=line><span class=cl><span class=c1># 用于指定docker0桥自身的IP地址 其他选项可以通过此地址计算得出</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=使用tcp套接字>使用TCP套接字</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># dockerd守护进程的C/S 其默认仅监听Unix Socket格式的地址 /var/run/docker.sock</span>
</span></span><span class=line><span class=cl><span class=c1># 如果使用TCP套接字 需要修改 /etc/docekr/daemon.json 配置文件</span>
</span></span><span class=line><span class=cl><span class=c1># 也可向dockerd直接传递 &#34;-H|--host&#34;选项</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;hosts&#34;</span>: <span class=o>[</span><span class=s2>&#34;tcp://0.0.0.0:2375&#34;</span>, <span class=s2>&#34;unix:///var/run/docker.sock&#34;</span><span class=o>]</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># dockerd使用TCP监听0.0.0.0:2375之后 客户端可以远程执行CLI</span>
</span></span><span class=line><span class=cl>$ docker -H x.x.x.x:2375 image ls
</span></span><span class=line><span class=cl>$ docker -H x.x.x.x:2375 ps -a
</span></span></code></pre></td></tr></table></div></div><h4 id=创建自定义网络>创建自定义网络</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 创建自定义网络</span>
</span></span><span class=line><span class=cl>$ docker network create -d bridge --subnet <span class=s2>&#34;172.26.0.0/16&#34;</span> --gateway <span class=s2>&#34;172.26.0.1&#34;</span> mybr0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 使用自定义网络</span>
</span></span><span class=line><span class=cl><span class=o>[</span>ilolicon@master ~<span class=o>]</span>$ docker run -it --rm --name t1 --network mybr0 busybox
</span></span><span class=line><span class=cl>/ <span class=c1># ifconfig</span>
</span></span><span class=line><span class=cl>eth0      Link encap:Ethernet  HWaddr 02:42:AC:1A:00:02  
</span></span><span class=line><span class=cl>          inet addr:172.26.0.2  Bcast:172.26.255.255  Mask:255.255.0.0
</span></span></code></pre></td></tr></table></div></div><h3 id=docker存储卷>docker存储卷</h3><h4 id=why-data-volumes存储卷>Why Data Volumes(存储卷)</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Docker镜像由多个<span class=s2>&#34;只读层&#34;</span>叠加而成 
</span></span><span class=line><span class=cl>启动容器时 Docker会加载只读镜像层并在镜像栈顶部添加一个<span class=s2>&#34;读写层&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>如果运行中的容器修改了现有的一个已经存在的文件
</span></span><span class=line><span class=cl>那该文件将会从读写层下面的只读层复制到读写层 该文件的只读版本<span class=s2>&#34;仍然存在&#34;</span>
</span></span><span class=line><span class=cl>只是已经被读写层中该文件的副本所隐藏 此即<span class=s2>&#34;写时复制(COW)&#34;</span>机制
</span></span></code></pre></td></tr></table></div></div><p><img src=/p/docker/icons/files-visible-to-a-container.png width=751 height=423 srcset="/p/docker/icons/files-visible-to-a-container_hu5bf186c999f6f34c90c9ad0a7dba16dd_138845_480x0_resize_box_3.png 480w, /p/docker/icons/files-visible-to-a-container_hu5bf186c999f6f34c90c9ad0a7dba16dd_138845_1024x0_resize_box_3.png 1024w" loading=lazy alt=file-visible class=gallery-image data-flex-grow=177 data-flex-basis=426px></p><ul><li>关闭并重启容器 其数据不受影响 但删除Docker容器 则其更改将会全部丢失</li><li>存在的问题<ul><li>存储于联合文件系统中 不易于宿主机访问(效率低)</li><li>容器间数据共享不便</li><li>删除容器其数据会丢失</li></ul></li><li>解决方案: &ldquo;<strong>卷</strong>(volume)&rdquo;<ul><li><strong>卷</strong>是容器上的一个或多个<strong>目录</strong> 此类目录可绕过联合文件系统 与宿主机上的某目录<strong>绑定(关联)</strong></li><li>Volume于容器初始化之时即会创建 由base image提供的卷中的数据会于此期间完成复制</li><li>Volume的初衷是独立于容器的生命周期实现数据持久化 因此删除容器之时既不会删除卷 也不会对哪怕未被引用的卷做垃圾回收操作(加选项可以)</li></ul></li></ul><p><img src=/p/docker/icons/volume.png width=693 height=192 srcset="/p/docker/icons/volume_huc6dd66b5d1fa365b97dd8d30d2bb4680_75141_480x0_resize_box_3.png 480w, /p/docker/icons/volume_huc6dd66b5d1fa365b97dd8d30d2bb4680_75141_1024x0_resize_box_3.png 1024w" loading=lazy alt=volume class=gallery-image data-flex-grow=360 data-flex-basis=866px></p><ul><li>卷为docker提供了独立于容器的数据管理机制<ul><li>可以把<strong>镜像</strong>想象成静态文件 -> 例如 <strong>程序</strong>; 把卷类比为动态内容 -> 例如 <strong>数据</strong>; 于是 镜像可以重用 而卷可以共享</li><li>卷实现了<strong>程序(镜像)</strong> 和 <strong>数据(卷)</strong> 分离 以及 <strong>程序(镜像)</strong> 和 <strong>制作镜像的主机</strong> 分离; 用户制作镜像时无需再考虑镜像运行的容器所在的主机的环境</li></ul></li></ul><p><img src=/p/docker/icons/volume2.png width=932 height=374 srcset="/p/docker/icons/volume2_hubb053bbe15fe56dbede9e549ddb24aef_129737_480x0_resize_box_3.png 480w, /p/docker/icons/volume2_hubb053bbe15fe56dbede9e549ddb24aef_129737_1024x0_resize_box_3.png 1024w" loading=lazy alt=volume2 class=gallery-image data-flex-grow=249 data-flex-basis=598px></p><h4 id=data-volumes>Data volumes</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Docekr有两种类型的卷 每种类型都在容器中存在一个挂载点 但在其宿主机上的位置有所不同
</span></span></code></pre></td></tr></table></div></div><ul><li>Bind mount volume(绑定挂在卷)<ul><li>a volume that points to a user-specified location on the host file system</li></ul></li><li>Docker-managed volume(Docker管理卷)<ul><li>the Docker daemon creates managed volumes in a portion of the host&rsquo;s file system that&rsquo;s owned by Docker</li></ul></li></ul><p><img src=/p/docker/icons/data-volumes.png width=1317 height=440 srcset="/p/docker/icons/data-volumes_hu4dfcbd12cf6b4d086e7fe173542ab64f_196844_480x0_resize_box_3.png 480w, /p/docker/icons/data-volumes_hu4dfcbd12cf6b4d086e7fe173542ab64f_196844_1024x0_resize_box_3.png 1024w" loading=lazy alt=data-volume class=gallery-image data-flex-grow=299 data-flex-basis=718px></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 在容器中使用Volumes</span>
</span></span><span class=line><span class=cl><span class=c1># 为docker run命令使用-v选项即可使用Volume</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Docker-managed volume</span>
</span></span><span class=line><span class=cl>$ docker run -it --name t1 -v /data busybox
</span></span><span class=line><span class=cl>$ docker inspect -f <span class=o>{{</span>.Mounts<span class=o>}}</span> t1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Bind-mount Volume</span>
</span></span><span class=line><span class=cl>$ docker run -it -v HOSTDIR:VOLUMEDIR --name t2 bustbox
</span></span><span class=line><span class=cl>$ docker inspect -f <span class=o>{{</span>.Mount<span class=o>}}</span> t2
</span></span></code></pre></td></tr></table></div></div><h4 id=sharing-volumes>Sharing volumes</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># There are tow ways to share volumes between containers</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 多个容器的卷使用同一个主机目录</span>
</span></span><span class=line><span class=cl>$ docker run -it --name t1 -v /docker/volumes/v1:/data busybox
</span></span><span class=line><span class=cl>$ docker run -it --name t2 -v /docker/volumes/v1:/data busybox
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 复制使用其他容器的卷 为docker run命令使用 --volumes-from 选项</span>
</span></span><span class=line><span class=cl>$ docker run -it --name t3 -v /docker/volumes/v1:/data busybox
</span></span><span class=line><span class=cl>$ docker run -it --name t4 --volumes-from t3 busybox
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 如果有多个容器需要共享网络名称空间(UTS Network IPC) 以及需要共享存储卷</span>
</span></span><span class=line><span class=cl><span class=c1># 可以 事先创建一个 基础容器 其他的容器都加入该容器的网络名称空间(Joined Container) 并且复制该容器使用的卷(--volumes-from)</span>
</span></span><span class=line><span class=cl>$ docker run --name infracon -it -v /data/infracon/volume:/data busybox
</span></span><span class=line><span class=cl>$ docker run --name nginx --network container:infracon --volumes-from infracon -it nginx
</span></span><span class=line><span class=cl>$ docker run ... --network container:infracon --volumes-from infracon ...
</span></span></code></pre></td></tr></table></div></div><h2 id=dockerfile>Dockerfile</h2><p><a class=link href=https://docs.docker.com/engine/reference/builder/ target=_blank rel=noopener>Dockerfile-reference</a></p><p>Dockerfile is nothing but the source code for building Docker images</p><ul><li>Docker can build images automatically by reading the instructions from a Dockerfile</li><li>A Dockerfile is a <code>text document</code> than contains all the commands a user could call on the command line to assemble an image</li><li>Using <code>docker build</code> users can create an automated build that executes several command-line instructions in succession</li></ul><p><img src=/p/docker/icons/docker-build.png width=490 height=242 srcset="/p/docker/icons/docker-build_hu78e016fdb09837500502497ac9124888_91582_480x0_resize_box_3.png 480w, /p/docker/icons/docker-build_hu78e016fdb09837500502497ac9124888_91582_1024x0_resize_box_3.png 1024w" loading=lazy alt=build class=gallery-image data-flex-grow=202 data-flex-basis=485px></p><h3 id=dockerfile-format>Dockerfile Format</h3><ul><li>Format<ul><li># Comment (注释)</li><li>INSTRUCTION arguments (指令及其参数 通常一行一个执行 太长使用<code>\</code>换行)</li></ul></li><li>The instruction is not case-sensitive (指令大小写不敏感)<ul><li>However, convention is for them to be UPPERCASE to distinguish them from arguments more easily (一般约定使用大写 和参数区分开)</li></ul></li><li>Docker runs instructions in a Dockerfile in order (顺序执行)</li><li>The first instruction must be <code>FROM</code> in order to specify the Base Image from which you are building (第一个非指数行 必须为<code>FROM</code>指令)</li></ul><h3 id=dockerignore-file>.dockerignore file</h3><ul><li>Before the docker CLI sends the context to the docker daemon, it looks for a file named .dockerignore in the root directory of the context</li><li>If this file exists, the CLI modifies the context to exclude files and directories than match patterns in it</li><li>The CLI interprets the .dockerignore file as a newline-separated list of patterns similar to the file globs of Unix shells</li></ul><h3 id=environment-replacement>Environment replacement</h3><ul><li>Environment variables (declared with the <code>ENV</code> statement) can also be used in certain instructions as variables to be interpred by the Dockerfile</li><li>Environment variables are notated in the Dockerfile either with $variable_name or ${variable_name}</li><li>The ${variable_name} syntax also supports a few of the standard bash modifiers<ul><li>${variable:-word} - 设置默认值 variable未设置或为空 则变量默认值为: word</li><li>${variable:+word} - 和 ${variable:-word} 相反</li></ul></li></ul><h3 id=docekrfile-instructions>Docekrfile Instructions</h3><h4 id=from>FROM</h4><ul><li><code>FROM</code>指令是最重要的一个且必须为Docekrfile文件开篇的第一个非注释行 用于为镜像文件构建过程指定基准镜像 后续的指令运行于此基准镜像所提供的运行环境</li><li>实践中 基准镜像可以是任何可用镜像文件 默认情况下 <code>docekr build</code>会在docker主机上查找指定的镜像文件 在其不存在时 则会从Docker Hub Registry上拉取所需的镜像文件<ul><li>如果找不到执行的镜像文件 <code>docker build</code>会返回一个错误信息</li></ul></li><li>Syntax<ul><li><code>FROM &lt;repository>[:&lt;tag>]</code> 或</li><li><code>FROM &lt;repository>@&lt;digest></code> @符号指定hash码 确保base image不会被篡改<ul><li><code>&lt;repository></code> 指定作为 base image 的名称</li><li><code>&lt;tag></code> base image 的标签 可选 省略时默认为latest</li></ul></li></ul></li></ul><h4 id=maintanierdeprecated>MAINTANIER(deprecated)</h4><ul><li>用于让Docekrfile制作者提供本人的详细信息</li><li>Dockerfile并不限制MAINTANIER指令出现的位置 但推荐将其放置于<code>FROM</code>指令后</li><li>Syntax<ul><li><code>MAINTANIER &lt;author's detail></code><ul><li><code>&lt;author's detail></code>可以是任何文本信息 但约定俗成地使用作者名称及其邮件地址</li><li><code>MAINTANIER "ilolicon &lt;97431110@qq.com>"</code></li></ul></li></ul></li></ul><h4 id=label>LABEL</h4><p>The LABEL instruction adds metadata to an image (可替换MAINTANIER 并可添加更多元数据信息)</p><ul><li>Syntax: <code>LABEL &lt;key>=&lt;value> &lt;key>=&lt;value> &lt;key>=&lt;value> ...</code></li><li>The LABEL instruction adds metadata to an image</li><li>A LABEL is a key-value pair</li><li>To include spaces within a LABEL value, use quotes and backslashes as you would in command-line parsing</li><li>An image can have more than one label</li><li>You can specify multiple labels on a single line</li></ul><h4 id=copy>COPY</h4><ul><li>用于从Docker主机复制文件至创建的新镜像文件</li><li>Syntax<ul><li><code>COPY &lt;src> ... &lt;dest></code> 或</li><li><code>COPY ["&lt;src>", ..., "&lt;dest>"]</code><ul><li><code>&lt;src></code> 要复制的源文件或目录 支持使用通配符</li><li><code>&lt;dest></code> 目标路径 即正在创建的image的文件系统路径 建议<code>&lt;dest></code>使用绝对路径 否则<code>COPY</code>指令则以WORKDIR为其起始路径</li></ul></li><li>注意: 在路径中有空白符时 通常使用第二种格式</li></ul></li><li>文件复制准则<ul><li><code>&lt;src></code>必须是build上下文中的路径 不能是其父目录中的文件</li><li>如果<code>&lt;src></code>是目录 则其内部文件或子目录会被递归复制 但是<code>&lt;src></code>目录本身不会被复制</li><li>如果指定多个<code>&lt;src></code> 或在<code>&lt;src></code>中使用了通配符 则<code>&lt;dest></code>必须是一个目录 且必须以<code>/</code>结尾</li><li>如果<code>&lt;dest></code>事先不存在 它将会被自动创建 这包括其父级目录</li></ul></li></ul><h4 id=add>ADD</h4><ul><li><code>ADD</code>指令类似于<code>COPY</code>指令 ADD支持使用TAR文件和URL路径</li><li>Syntax<ul><li><code>ADD &lt;src> ... &lt;dest></code> 或</li><li><code>ADD ["&lt;src>", ..., "&lt;dest>"]</code></li></ul></li><li>操作准则<ul><li>同<code>COPY</code>指令</li><li>URL<ul><li>如果<code>&lt;src></code>为URL且<code>&lt;dest></code>不以<code>/</code>结尾 则<code>&lt;src></code>指定的文件将被下载并直接被创建为<code>&lt;dest></code></li><li>如果<code>&lt;src></code>为URL且<code>&lt;dest></code>以<code>/</code>结尾 则文件名URL指定的文件将被下载并保存为<code>&lt;dest>/&lt;filename></code></li></ul></li><li>TAR<ul><li>如果<code>&lt;src></code>是一个本地系统上的压缩格式的tar文件 它将被展开为一个目录 其行为类似于<code>tar -x</code>命令 然而 通道URL获取到的tar文件将不会自动展开</li></ul></li><li>如果<code>&lt;src></code>有多个 或其间接或直接使用了通配符 则<code>&lt;dest></code>必须是一个以<code>/</code>结尾的目录路径 如果<code>&lt;dest></code>不以<code>/</code>结尾 则其将被视为一个普通文件 <code>&lt;src></code>的内容将被直接写入到<code>&lt;dest></code></li></ul></li></ul><h4 id=workdir>WORKDIR</h4><ul><li>用于为Dockerfile中所有的<code>RUN/CMD/ENTRYPOINT/COPY/ADD</code>指令设置工作目录</li><li>Syntax<ul><li><code>WORKDIR &lt;dirpath></code><ul><li>在Dockerfile中 <code>WORKDIR</code>指令可以出现多次 其路径也可以为相对路径 不过其是相对此前一个<code>WODKDIR</code>指令指定的路径</li><li>另外 <code>WORKDIR</code>也可调用由<code>ENV</code>指令定义的变量</li></ul></li><li>e.g<ul><li><code>WORKDIR /var/log</code></li><li><code>WORKDIR $STATEPATH</code></li></ul></li></ul></li></ul><h4 id=volume>VOLUME</h4><ul><li>用于在image中创建一个挂载点目录 以挂载Docker host上的卷或其他容器上的卷</li><li>Syntax<ul><li><code>VOLUME &lt;mountpoint></code> 或</li><li><code>VOLUME ["&lt;mountpoint>"]</code></li></ul></li><li>如果挂载点目录路径下此前在文件存在 <code>docker run</code>命令会在挂载完成后将此前的所有文件复制到新挂载的卷中</li></ul><h4 id=expose>EXPOSE</h4><ul><li>用于为容器打开指定要监听的端口 以实现与外部通信</li><li>Syntax<ul><li><code>EXPOSE &lt;port>[/&lt;protocol>] [&lt;port>[/protocol]...]</code><ul><li><code>&lt;protocol></code>用于指定传输层协议 可为tcp或udp二者之一 默认为TCP协议</li></ul></li><li><code>EXPOSE</code>指令可一次指定多个端口<ul><li><code>EXPOSE 11211/udp 11211/tcp</code></li></ul></li></ul></li></ul><h4 id=env>ENV</h4><ul><li>用于为镜像定义所需的环境变量 并可被Dockerfile文件中位与其后的其它指令(如<code>ENV/ADD/COPY</code>等)所调用</li><li>调用格式为 $variable_name 或 ${variable_name}</li><li>Syntax<ul><li><code>ENV &lt;key> &lt;value></code> 或</li><li><code>ENV &lt;key>=&lt;value> ...</code></li></ul></li><li>第一种格式中: <code>&lt;key></code>之后的所有内容均会被视作其<code>&lt;value></code>的组成部分 因此 一次只能设置一个变量</li><li>第二种格式中: 可以一次设置多个变量 每个变量为一个<code>&lt;key>=&lt;value></code>的键值对 如果<code>&lt;value></code>中包含空格 可以以反斜线<code>\</code>进行转义 也可以通过对<code>&lt;value></code>加引号进行标识 另外 反斜线也用于续行</li><li>定义多个变量时 建议使用第二种方式 以便在同一层中完成所有功能</li></ul><h4 id=run>RUN</h4><ul><li>用于指定<code>docker build</code>过程中运行的程序 其可以是任何命令(基于base image提供)</li><li>Syntax<ul><li><code>RUN &lt;command></code> 或</li><li><code>RUN ["&lt;executable>", "&lt;param1>", "&lt;param2>"]</code></li></ul></li><li>第一种格式中 <code>&lt;command></code> 通常是一个shell命令 且以<code>/bin/sh -c</code>来运行它 这意味着此进程在容器中的PID不是1 不能接收Unix信号 因此 当使用<code>docker stop &lt;container></code>命令停止容器时 此进程接收不到SIGTERM信号</li><li>第二种语法格式中的参数是一个JSON格式的数组 其中<code>&lt;executable></code>为要运行的命令 后面的<code>&lt;paramN></code>为传递给命令的选项或参数 然而 此种格式指定的命令不会以<code>/bin/sh -c</code>来发起 因此常见的shell操作如变量替换以及通配符<code>? *等</code>替换将不会进行 不过如果要运行的命令依赖于此shell特性的话 可以将其替换为类似下面的格式<ul><li><code>RUN ["/bin/sh", "-c", "&lt;executable>", "&lt;param1>"]</code></li><li>Json数组中 注意要使用<strong>双引号</strong></li></ul></li></ul><h4 id=cmd>CMD</h4><ul><li>类似于<code>RUN</code>指令 <code>CMD</code>指令也可用于运行任何命令或应用程序 不过 二者的运行时间点不同<ul><li><code>RUN</code>指令运行于映像文件构建过程中 而<code>CMD</code>指令运行于基于Dockerfile构建出的新映像文件启动一个容器时</li><li><code>CMD</code>指令的首要目的在于为启动的容器指定<code>默认</code>要运行的程序 且其运行结束后 容器也将终止 不过<code>CMD</code>指定的命令可以被<code>docker run</code>的命令行选项所覆盖</li><li>在Docekrfile中 可以存在多个<code>CMD</code>指令 但仅最后一个会生效</li></ul></li><li>Syntax<ul><li><code>CMD &lt;command></code> 或</li><li><code>CMD ["&lt;executable>", "&lt;param1>", "&lt;param2>"]</code> 或</li><li><code>CMD ["&lt;param1>", "&lt;param2>"]</code></li></ul></li><li>前两种语法格式的意义同<code>RUN</code></li><li>都三种则用于为<code>ENTRYPOINT</code>指令提供默认参数</li></ul><h4 id=entrypoint>ENTRYPOINT</h4><ul><li>类似<code>CMD</code>指令的功能 用于为容器指定默认运行程序 从而使得容器像是一个单独的可执行程序</li><li>与<code>CMD</code>不同的是 由<code>ENTRYPOINT</code>启动的程序不会被<code>docker run</code>命令行指定的参数所覆盖 而且 这些命令行参数会被当作参数传递给<code>ENTRYPOINT</code>指令指定的程序<ul><li>不过 <code>docker run</code>命令的<code>--entrypoint</code>选项的参数 可以覆盖<code>ENTRYPOINT</code>指令指定的程序</li></ul></li><li>Syntax<ul><li><code>ENTRYPOINT &lt;command></code></li><li><code>ENTRYPOINT ["&lt;executable>", "&lt;param1>", "&lt;param2>"]</code></li></ul></li><li><code>docker run</code>命令传入的命令参数会覆盖<code>CMD</code>指令的内容 并且附加到<code>ENTRYPOINT</code>命令最后作为其参数使用</li><li>Dockerfile文件中也可以存在多个<code>ENTRYPOINT</code>指令 但仅有最后一个会生效</li></ul><p>Tips: 使用<code>ENTRYPOINT</code>解决配置文件<strong>环境变量</strong>使用问题</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 问题: nginx(或其他程序)配置文件有许多需要修改的配置</span>
</span></span><span class=line><span class=cl><span class=c1># 比如: root_dir / listen_ip / listen_port 等等 </span>
</span></span><span class=line><span class=cl><span class=c1># 使用容器的情况下 如何更优的解决该问题?</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>docker-entrypoint.sh</li></ul><p><a class=link href=https://github.com/docker-library/mysql/blob/master/5.7/docker-entrypoint.sh target=_blank rel=noopener>refer:MySQL dokcer-entrypoint.sh</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=cp>#!/bin/sh
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1># 根据变量(环境变量/自定义变量)生成配置文件</span>
</span></span><span class=line><span class=cl><span class=c1># 需要修改的 传入环境变量的方式 比如: APP_ENV: TEST|PROD|DEV</span>
</span></span><span class=line><span class=cl><span class=c1># docker run -d --name=ngx --env PORT=8080 --env XX=XX --rm ngx:v1</span>
</span></span><span class=line><span class=cl><span class=nv>IP</span><span class=o>=</span><span class=k>$(</span>ip address show dev eth0 <span class=p>|</span> awk <span class=s1>&#39;/inet /{split($2, ip, &#34;/&#34;);print ip[1]}&#39;</span><span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>cat &gt; /etc/nginx/conf.d/www.conf <span class=s>&lt;&lt; EOF
</span></span></span><span class=line><span class=cl><span class=s>server {
</span></span></span><span class=line><span class=cl><span class=s>    server_name ${HOSTNAME};
</span></span></span><span class=line><span class=cl><span class=s>    listen ${IP:-0.0.0.0}:${PORT:-80};
</span></span></span><span class=line><span class=cl><span class=s>    root ${NGX_DOC_ROOT:-/usr/share/nginx/html/};
</span></span></span><span class=line><span class=cl><span class=s>}
</span></span></span><span class=line><span class=cl><span class=s>
</span></span></span><span class=line><span class=cl><span class=s>EOF</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Dockerfile CMD指定的参数($@) 取代当前shell 成为 main-process</span>
</span></span><span class=line><span class=cl><span class=nb>exec</span> <span class=s2>&#34;</span><span class=nv>$@</span><span class=s2>&#34;</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>Dockerfile</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Dockerfile data-lang=Dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> nginx:1.14-alpine</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>LABEL</span> <span class=nv>maintainer</span><span class=o>=</span><span class=s2>&#34;ilolicon &lt;97431110@qq.com&gt;&#34;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ENV</span> <span class=nv>NGX_DOC_ROOT</span><span class=o>=</span><span class=s2>&#34;/data/www/html/&#34;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ADD</span> index.html <span class=nv>$NGX_DOC_ROOT</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ADD</span> docker-entrypoint.sh /bin/<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span><span class=s2>&#34;/usr/sbin/nginx&#34;</span><span class=p>,</span> <span class=s2>&#34;-g&#34;</span><span class=p>,</span> <span class=s2>&#34;daemon off&#34;</span><span class=p>]</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># CMD指令参数 传递给docker-entrypoint.sh脚本 脚本用$@获取全部参数</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ENTRYPOINT</span> <span class=p>[</span><span class=s2>&#34;/bin/docker-entrypoint.sh&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=user>USER</h4><ul><li>用于指定运行image时或运行Dockerfile中任何<code>RUN CMD 或 ENTRYPOINT</code>指令指定的程序时的用户名或UID</li><li>默认情况下 container的运行身份为root用户</li><li>Syntax<ul><li><code>USER &lt;UID>|&lt;UserName></code></li><li>需要注意的是 <code>&lt;UID></code>可以为任意数字 但实践中其必须为<code>/etc/passwd</code>(容器中)中某用户的有效UID 否则<code>docker run</code>命令将运行失败</li></ul></li></ul><h4 id=healthcheck>HEALTHCHECK</h4><p><a class=link href=https://docs.docker.com/engine/reference/builder/#healthcheck target=_blank rel=noopener>HEALTHCHECK</a></p><ul><li>The <code>HEALTHCHECK</code> instruction tells Docker how to test a container to check that it is still working</li><li>This can detect cases such as a web server that is stuck in an infinite loop and unable to handle new connections, even though the server process is still running</li><li>The HEALTHCHECK instruction has two forms<ul><li><code>HEALTHCHECK [OPTIONS] CMD command</code> (check container health by running a command inside the container)</li><li><code>HEALTHCHECK NONE</code> (disable any healthcheck inherited from the base image)</li></ul></li><li>The options that can appear before CMD are:<ul><li>&ndash;interval=DURATION (default: 30s)</li><li>&ndash;timeout=DURATION (default: 30s)</li><li>&ndash;start-period=DURATION (default: 0s) - 多少秒之后开始检测 等待container init的时间</li><li>&ndash;retries=N (default: 3)</li></ul></li><li>The command’s exit status indicates the health status of the container. The possible values are:<ul><li>0: success - the container is healthy and ready for use</li><li>1: unhealthy - the container is not working correctly</li><li>2: reserved - do not use this exit code - 预留 不要使用</li></ul></li><li>For example<ul><li><code>HEALTHCHECK --interval=5m --timeout=3s CMD curl -f http://localhost/ || exit 1</code></li></ul></li></ul><h4 id=shell>SHELL</h4><p><a class=link href=https://docs.docker.com/engine/reference/builder/#shell target=_blank rel=noopener>SHELL</a></p><ul><li>The <code>SHELL</code> instruction allows the default <em>shell</em> used for the shell form of commands to be overridden</li><li>The default shell on Linux is ["/bin/sh", &ldquo;-c&rdquo;], and on Windows is [&ldquo;cmd&rdquo;, &ldquo;/S&rdquo;, &ldquo;/C&rdquo;]</li><li>The <code>SHELL</code> instruction must be written in JSON form in a Dockerfile<ul><li>Syntax: SHELL [&ldquo;executable&rdquo;, &ldquo;parameters&rdquo;]</li></ul></li><li>The <code>SHELL</code> instruction can appear multiple times</li><li>Each <code>SHELL</code> instruction overrides all previous <code>SHELL</code> instructions, and affects all subsequent instruction</li></ul><h4 id=stopsignal>STOPSIGNAL</h4><p><a class=link href=https://docs.docker.com/engine/reference/builder/#stopsignal target=_blank rel=noopener>STOPSIGNAL</a></p><ul><li>The <code>STOPSIGNAL</code> instruction sets the system call signal that will be sent to the container to exit</li><li>This signal can be a signal name in the format <code>SIG&lt;NAME></code>, for instance <code>SIGKILL</code>, or an unsigned number that matches a position in the kernel’s syscall table, for instance <code>9</code><ul><li>The default is <code>SIGTERM</code> if not defined</li></ul></li><li>Syntax: <code>STOPSIGNAL signal</code></li></ul><h4 id=arg>ARG</h4><p><a class=link href=https://docs.docker.com/engine/reference/builder/#arg target=_blank rel=noopener>ARG</a></p><ul><li>The ARG instruction defines a variable that users can pass at build-time to the builder with the docker build command using the <code>--build-arg &lt;varname>=&lt;value></code> flag</li><li>If a user specifies a build argument that was not defined in the Dockerfile, the build outputs a warning<ul><li><code>[Warning] One or more build-args [foo] were not consumed.</code></li></ul></li><li>Syntax: <code>ARG &lt;name>[=&lt;default value>]</code></li><li>A Dockerfile may include one or more <code>ARG</code> instructions</li><li>An <code>ARG</code> instruction can optionally include a default value:<ul><li><code>ARG user1=someuser</code></li><li><code>ARG buildno=1</code></li></ul></li></ul><p>⚠️ <strong>Warning</strong>
It is not recommended to use build-time variables for passing secrets like github keys, user credentials etc. Build-time variable values are visible to any user of the image with the <code>docker history</code> command.</p><p>Refer to the <a class=link href=https://docs.docker.com/develop/develop-images/build_enhancements/#new-docker-build-secret-information target=_blank rel=noopener>&ldquo;build images with BuildKit&rdquo;</a> section to learn about secure ways to use secrets when building images.</p><h4 id=onbuild>ONBUILD</h4><ul><li>用于在Dockerfile中定义一个触发器</li><li>Dockerfile用于build映像文件 此映像文件亦可作为base image被另一个Dockerfile用作<code>FROM</code>指令的参数 并以之构建新的镜像文件</li><li>在后面的这个Dockerfile中的<code>FROM</code>指令在build过程中被执行时 将会<strong>触发</strong>创建其base image的Dockerfile文件中的<code>ONBUILD</code>指令定义的触发器</li><li>Syntax<ul><li><code>ONBUILD &lt;INSTRUCTION></code></li></ul></li><li>尽管任何指令都可以注册成为触发器指令 但<code>ONBUILD</code>不能自我嵌套 且不会触发<code>FROM</code>和<code>MAINTAINER</code>指令</li><li>使用包含<code>ONBUILD</code>指令的Dockerfile构建的镜像应该使用特殊的标签<ul><li>e.g: ruby:2.0-onbuild</li></ul></li><li>在<code>ONBUILD</code>指令中使用<code>ADD</code>或<code>COPY</code>指令应该格外小心 因为新 构建过程的上下文在缺少指定的源文件时会失败</li></ul><h2 id=docker资源限制>Docker资源限制</h2><p><a class=link href=https://docs.docker.com/config/containers/resource_constraints/ target=_blank rel=noopener>Limit a container&rsquo;s resources</a></p><ul><li>By default, a container has no resource constraints and can use as much of a given resource as the host’s kernel scheduler allows</li><li>Docker provides ways to control how much memory, or CPU a container can use, setting runtime configuration flags of the <code>docker run</code> command</li><li>Many of these features require your kernel to support Linux capabilities<ul><li>To check for support, you can use the <code>docker info</code> command</li></ul></li></ul><h3 id=oome>OOME</h3><ul><li>On Linux hosts, if the kernel detects that there is not enough memory to perform important system functions, it throws an <code>OOME</code>, or <code>Out Of Memory Exception</code>, and starts killing processes to free up memory<ul><li>一旦发生OOME 任何进程都有可能被杀死 包括docker daemon在内</li><li>为此 Docker特地调整了docker daemon的OOM优先级 以免它被内核"正法" 但容器优先级并为调整</li><li><code>Memory Hogs</code> <code>OOM_ADJ</code> <code>OOM_SCORE</code></li></ul></li></ul><h4 id=limit-a-containers-access-to-memory>Limit a container’s access to memory</h4><ul><li>Docker can enforce hard memory limits, which allow the container to use no more than a given amount of user or system memory</li><li>or soft limits, which allow the container to use as much memory as it needs unless certain conditions are met, such as when the kernel detects low memory or contention on the host machine</li><li>Some of these options have different effects when used alone or when more than one option is set</li><li>Most of these options take a positive integer, followed by a suffix of <code>b, k, m, g</code>, to indicate bytes, kilobytes, megabytes, or gigabytes</li></ul><div class=table-wrapper><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td><code>-m</code> or <code>--memory=</code></td><td>The maximum amount of memory the container can use. If you set this option, the minimum allowed value is <code>6m</code> (6 megabytes). That is, you must set the value to at least 6 megabytes.</td></tr><tr><td><code>--memory-swap *</code></td><td>The amount of memory this container is allowed to swap to disk. See <a class=link href=https://docs.docker.com/config/containers/resource_constraints/#--memory-swap-details target=_blank rel=noopener><code>--memory-swap</code> details</a>.</td></tr><tr><td><code>--memory-swappiness</code></td><td>By default, the host kernel can swap out a percentage of anonymous pages used by a container. You can set <code>--memory-swappiness</code> to a value between 0 and 100, to tune this percentage. See <a class=link href=https://docs.docker.com/config/containers/resource_constraints/#--memory-swappiness-details target=_blank rel=noopener><code>--memory-swappiness</code> details</a>.</td></tr><tr><td><code>--memory-reservation</code></td><td>Allows you to specify a soft limit smaller than <code>--memory</code> which is activated when Docker detects contention or low memory on the host machine. If you use <code>--memory-reservation</code>, it must be set lower than <code>--memory</code> for it to take precedence. Because it is a soft limit, it does not guarantee that the container doesn’t exceed the limit.</td></tr><tr><td><code>--kernel-memory</code></td><td>The maximum amount of kernel memory the container can use. The minimum allowed value is <code>4m</code>. Because kernel memory cannot be swapped out, a container which is starved of kernel memory may block host machine resources, which can have side effects on the host machine and on other containers. See <a class=link href=https://docs.docker.com/config/containers/resource_constraints/#--kernel-memory-details target=_blank rel=noopener><code>--kernel-memory</code> details</a>.</td></tr><tr><td><code>--oom-kill-disable</code></td><td>By default, if an out-of-memory (OOM) error occurs, the kernel kills processes in a container. To change this behavior, use the <code>--oom-kill-disable</code> option. Only disable the OOM killer on containers where you have also set the <code>-m/--memory</code> option. If the <code>-m</code> flag is not set, the host can run out of memory and the kernel may need to kill the host system’s processes to free memory.</td></tr></tbody></table></div><h4 id=--memory-swap>&ndash;memory-swap</h4><ul><li>Using swap allows the container to write excess memory requirements to disk when the container has exhausted all the RAM that is available to it</li><li><code>--memory-swap</code> is a modifier flag that only has meaning if <code>--memory</code> is also set</li></ul><div class=table-wrapper><table><thead><tr><th><code>--memory-swap</code></th><th><code>--memory</code></th><th>功能</th></tr></thead><tbody><tr><td>正数S</td><td>正数M</td><td>容器可用总空间为S 其中ram为M swap为(S-M) 若S=M 则无可用swap资源</td></tr><tr><td>0</td><td>正数M</td><td>相当于未设置swap(unset)</td></tr><tr><td>unset</td><td>正数M</td><td>若主机(Docker Host)启用了swap 则容器的可用swap为 2*M</td></tr><tr><td>-1</td><td>正数M</td><td>若主机(Docker Host)启用了swap 则容器可使用最大至主机的所有swap空间的swap资源</td></tr></tbody></table></div><p>⚠️ <strong>注意:</strong> 在容器内使用free命令可以看到的swap空间 并不具有其所展示出的空间指示意义</p><h3 id=cpu>CPU</h3><p><a class=link href=https://linux.cn/article-7325-1.html target=_blank rel=noopener>深入Linux的进程优先级</a></p><ul><li>By default, each container’s access to the host machine’s CPU cycles is unlimited</li><li>You can set various constraints to limit a given container’s access to the host machine’s CPU cycles</li><li>Most users use and configure the <a class=link href=https://docs.docker.com/config/containers/resource_constraints/#configure-the-default-cfs-scheduler target=_blank rel=noopener>default CFS scheduler</a></li><li>You can also configure the <a class=link href=https://docs.docker.com/config/containers/resource_constraints/#configure-the-realtime-scheduler target=_blank rel=noopener>realtime scheduler</a>.</li></ul><h4 id=configure-the-default-cfs-scheduler>Configure the default CFS scheduler</h4><p>The CFS is the Linux kernel CPU scheduler for normal Linux processes. Several runtime flags allow you to configure the amount of access to CPU resources your container has. When you use these settings, Docker modifies the settings for the container’s cgroup on the host machine.</p><div class=table-wrapper><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td><code>--cpus=&lt;value></code></td><td>Specify how much of the available CPU resources a container can use. For instance, if the host machine has two CPUs and you set <code>--cpus="1.5"</code>, the container is guaranteed at most one and a half of the CPUs. This is the equivalent of setting <code>--cpu-period="100000"</code> and <code>--cpu-quota="150000"</code>.</td></tr><tr><td><code>--cpu-period=&lt;value></code></td><td>Specify the CPU CFS scheduler period, which is used alongside <code>--cpu-quota</code>. Defaults to 100000 microseconds (100 milliseconds). Most users do not change this from the default. For most use-cases, <code>--cpus</code> is a more convenient alternative.</td></tr><tr><td><code>--cpu-quota=&lt;value></code></td><td>Impose a CPU CFS quota on the container. The number of microseconds per <code>--cpu-period</code> that the container is limited to before throttled. As such acting as the effective ceiling. For most use-cases, <code>--cpus</code> is a more convenient alternative.</td></tr><tr><td><code>--cpuset-cpus</code></td><td>Limit the specific CPUs or cores a container can use. A comma-separated list or hyphen-separated range of CPUs a container can use, if you have more than one CPU. The first CPU is numbered 0. A valid value might be <code>0-3</code> (to use the first, second, third, and fourth CPU) or <code>1,3</code> (to use the second and fourth CPU).</td></tr><tr><td><code>--cpu-shares</code></td><td>Set this flag to a value greater or less than the default of 1024 to increase or reduce the container’s weight, and give it access to a greater or lesser proportion of the host machine’s CPU cycles. This is only enforced when CPU cycles are constrained. When plenty of CPU cycles are available, all containers use as much CPU as they need. In that way, this is a soft limit. <code>--cpu-shares</code> does not prevent containers from being scheduled in swarm mode. It prioritizes container CPU resources for the available CPU cycles. It does not guarantee or reserve any specific CPU access.</td></tr></tbody></table></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># If you have 1 CPU, each of the following commands guarantees the container at most 50% of the CPU every second.</span>
</span></span><span class=line><span class=cl>$ docker run -it --cpus<span class=o>=</span><span class=s2>&#34;.5&#34;</span> ubuntu /bin/bash
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Which is the equivalent to manually specifying --cpu-period and --cpu-quota;</span>
</span></span><span class=line><span class=cl>$ docker run -it --cpu-period<span class=o>=</span><span class=m>100000</span> --cpu-quota<span class=o>=</span><span class=m>50000</span> ubuntu /bin/bash
</span></span></code></pre></td></tr></table></div></div><h3 id=测试>测试</h3><p><a class=link href=https://hub.docker.com/r/polinux/stress target=_blank rel=noopener>stress</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 使用stress镜像 进行测试</span>
</span></span><span class=line><span class=cl>$ docker run -ti --rm polinux/stress stress --cpu <span class=m>1</span> --io <span class=m>1</span> --vm <span class=m>1</span> --vm-bytes 128M --timeout 1s --verbose
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 显示容器的运行进程</span>
</span></span><span class=line><span class=cl>$ docker top CONTAINER
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 显示容器资源使用统计的实时流</span>
</span></span><span class=line><span class=cl>$ docker stats
</span></span></code></pre></td></tr></table></div></div></section><footer class=article-footer><section class=article-tags><a href=/tags/cloud-native/>Cloud Native</a>
<a href=/tags/docker/>Docker</a>
<a href=/tags/dockerfile/>Dockerfile</a>
<a href=/tags/container/>Container</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/coredns/><div class=article-details><h2 class=article-title>CoreDNS</h2></div></a></article><article><a href=/p/tekton/><div class=article-details><h2 class=article-title>Tekton</h2></div></a></article><article><a href=/p/kubernetes/><div class=article-details><h2 class=article-title>Kubernetes</h2></div></a></article><article><a href=/p/prometheus/><div class=article-details><h2 class=article-title>Prometheus</h2></div></a></article></div></div></aside><script src=https://utteranc.es/client.js repo=ilolicon/ilolicon.github.io issue-term=pathname crossorigin=anonymous async></script><style>.utterances{max-width:unset}</style><script>let utterancesLoaded=!1;function setUtterancesTheme(e){let t=document.querySelector(".utterances iframe");t&&t.contentWindow.postMessage({type:"set-theme",theme:`github-${e}`},"https://utteranc.es")}addEventListener("message",e=>{if(e.origin!=="https://utteranc.es")return;utterancesLoaded=!0,setUtterancesTheme(document.documentElement.dataset.scheme)}),window.addEventListener("onColorSchemeChange",e=>{if(!utterancesLoaded)return;setUtterancesTheme(e.detail)})</script><footer class=site-footer><section class=copyright>&copy;
2017 -
2025 ilolicon's Blog</section><section class=powerby>Vicissitude🐳<br>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.21.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>